{\rtf1\ansi\ansicpg1252\cocoartf2818
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red12\green98\blue192;\red255\green255\blue254;\red0\green0\blue0;
\red15\green118\blue104;\red204\green0\blue137;\red18\green135\blue47;\red252\green103\blue8;}
{\*\expandedcolortbl;;\cssrgb\c0\c47059\c80000;\cssrgb\c100000\c100000\c99608;\cssrgb\c0\c0\c0;
\cssrgb\c0\c52941\c48235;\cssrgb\c84706\c0\c60784;\cssrgb\c0\c58824\c24314;\cssrgb\c100000\c49020\c0;}
\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 from\cf0 \strokec4  spike \cf2 \strokec2 import\cf0 \strokec4  PrimeHub, LightMatrix, Button, StatusLight, ForceSensor, MotionSensor, Speaker, ColorSensor, App, DistanceSensor, Motor, MotorPair\cb1 \
\cf2 \cb3 \strokec2 from\cf0 \strokec4  spike.control \cf2 \strokec2 import\cf0 \strokec4  wait_for_seconds, wait_until, Timer\cb1 \
\cf2 \cb3 \strokec2 from\cf0 \strokec4  math \cf2 \strokec2 import\cf0 \strokec4  *\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf0 \cb3 hub = PrimeHub\cf5 \strokec5 ()\cf0 \cb1 \strokec4 \
\cb3 drive_base = MotorPair\cf5 \strokec5 (\cf6 \strokec6 'C'\cf0 \strokec4 , \cf6 \strokec6 'F'\cf5 \strokec5 )\cf0 \cb1 \strokec4 \
\cb3 LeftMotor = Motor\cf5 \strokec5 (\cf6 \strokec6 'C'\cf5 \strokec5 )\cf0 \cb1 \strokec4 \
\cb3 RightMotor = Motor\cf5 \strokec5 (\cf6 \strokec6 'F'\cf5 \strokec5 )\cf0 \cb1 \strokec4 \
\cb3 tail = Motor\cf5 \strokec5 (\cf6 \strokec6 'A'\cf5 \strokec5 )\cf0 \cb1 \strokec4 \
\cb3 arm = Motor\cf5 \strokec5 (\cf6 \strokec6 'E'\cf5 \strokec5 )\cf0 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf7 \cb3 \strokec7 # r_col = ColorSensor('D')\cf0 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf0 \cb3 l_col = ColorSensor\cf5 \strokec5 (\cf6 \strokec6 'B'\cf5 \strokec5 )\cf0 \cb1 \strokec4 \
\cb3 timer = Timer\cf5 \strokec5 ()\cf0 \cb1 \strokec4 \
\cb3 WHEEL_DIAMETER = \cf8 \strokec8 5.6\cf0 \strokec4  \cf7 \strokec7 # small spike wheel in cm\cf0 \cb1 \strokec4 \
\cb3 drive_base.set_stop_action\cf5 \strokec5 (\cf6 \strokec6 'brake'\cf5 \strokec5 )\cf0 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf6 \cb3 \strokec6 '''\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6 Turns the robot left or right as long as the angle is not larger than 180\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6 Angle is relative to current robot heading (resets heading prior to turning)\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6 '''\cf0 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 def\cf0 \strokec4  turn\cf5 \strokec5 (\cf0 \strokec4 target_heading, speed, momentum_error=\cf8 \strokec8 0\cf0 \strokec4 , factor = \cf8 \strokec8 0.24\cf5 \strokec5 )\cf0 \strokec4 :\cb1 \
\pard\pardeftab720\partightenfactor0
\cf0 \cb3     \cf7 \strokec7 # speed must be positive\cf0 \cb1 \strokec4 \
\cb3     speed = \cf2 \strokec2 abs\cf5 \strokec5 (\cf0 \strokec4 speed\cf5 \strokec5 )\cf0 \cb1 \strokec4 \
\
\cb3     \cf7 \strokec7 # reset yaw angle to 0\cf0 \cb1 \strokec4 \
\cb3     hub.motion_sensor.reset_yaw_angle\cf5 \strokec5 ()\cf0 \cb1 \strokec4 \
\
\cb3     \cf7 \strokec7 # get initial robot heading\cf0 \cb1 \strokec4 \
\cb3     robot_heading = hub.motion_sensor.get_yaw_angle\cf5 \strokec5 ()\cf0 \cb1 \strokec4 \
\
\cb3     \cf7 \strokec7 # keep turning until goal is reached while accounting for potential momentum error\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 while\cf0 \strokec4  \cf2 \strokec2 abs\cf5 \strokec5 (\cf0 \strokec4 robot_heading\cf5 \strokec5 )\cf0 \strokec4  < \cf5 \strokec5 (\cf2 \strokec2 abs\cf5 \strokec5 (\cf0 \strokec4 target_heading\cf5 \strokec5 )\cf0 \strokec4  - momentum_error\cf5 \strokec5 )\cf0 \strokec4 :\cb1 \
\cb3         \cf7 \strokec7 # Calculate the remaining angle to the target\cf0 \cb1 \strokec4 \
\cb3         remaining_angle = \cf2 \strokec2 abs\cf5 \strokec5 (\cf0 \strokec4 target_heading\cf5 \strokec5 )\cf0 \strokec4  - \cf2 \strokec2 abs\cf5 \strokec5 (\cf0 \strokec4 robot_heading\cf5 \strokec5 )\cf0 \cb1 \strokec4 \
\
\cb3         \cf7 \strokec7 # Apply a simple deceleration based on the remaining angle\cf0 \cb1 \strokec4 \
\cb3         deceleration_factor = \cf2 \strokec2 max\cf5 \strokec5 (\cf0 \strokec4 factor, \cf2 \strokec2 min\cf5 \strokec5 (\cf8 \strokec8 1\cf0 \strokec4 , remaining_angle / \cf2 \strokec2 abs\cf5 \strokec5 (\cf0 \strokec4 target_heading\cf5 \strokec5 )))\cf0 \cb1 \strokec4 \
\cb3         adjusted_speed = \cf2 \strokec2 int\cf5 \strokec5 (\cf0 \strokec4 speed * deceleration_factor\cf5 \strokec5 )\cf0 \cb1 \strokec4 \
\
\cb3         \cf7 \strokec7 # Turns the robot left or right depending on the target heading sign (positive or negative)\cf0 \cb1 \strokec4 \
\cb3         right_speed = -adjusted_speed * \cf2 \strokec2 int\cf5 \strokec5 (\cf0 \strokec4 target_heading / \cf2 \strokec2 abs\cf5 \strokec5 (\cf0 \strokec4 target_heading\cf5 \strokec5 ))\cf0 \cb1 \strokec4 \
\cb3         left_speed = adjusted_speed * \cf2 \strokec2 int\cf5 \strokec5 (\cf0 \strokec4 target_heading / \cf2 \strokec2 abs\cf5 \strokec5 (\cf0 \strokec4 target_heading\cf5 \strokec5 ))\cf0 \cb1 \strokec4 \
\
\cb3         \cf7 \strokec7 # Start turning\cf0 \cb1 \strokec4 \
\cb3         drive_base.start_tank\cf5 \strokec5 (\cf0 \strokec4 left_speed, right_speed\cf5 \strokec5 )\cf0 \cb1 \strokec4 \
\
\cb3         \cf7 \strokec7 # Update heading measurement\cf0 \cb1 \strokec4 \
\cb3         robot_heading = hub.motion_sensor.get_yaw_angle\cf5 \strokec5 ()\cf0 \cb1 \strokec4 \
\
\cb3     \cf7 \strokec7 # Stop turning\cf0 \cb1 \strokec4 \
\cb3     drive_base.stop\cf5 \strokec5 ()\cf0 \cb1 \strokec4 \
\
\
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 def\cf0 \strokec4  go\cf5 \strokec5 (\cf0 \strokec4 target_distance, max_speed, target_heading, kp=\cf8 \strokec8 1.0\cf5 \strokec5 )\cf0 \strokec4 :\cb1 \
\pard\pardeftab720\partightenfactor0
\cf0 \cb3     \cf6 \strokec6 """\cf0 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf6 \cb3 \strokec6     Move robot straight with adaptive acceleration and deceleration\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6     Automatically balances speed and precision based on distance and speed\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6     Args:\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6         target_distance: distance to travel in cm\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6         max_speed: maximum speed (-100 to 100, negative for backward)\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6         target_heading: target heading angle in degrees\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6         kp: proportional gain for heading correction\cf0 \cb1 \strokec4 \
\cf6 \cb3 \strokec6     """\cf0 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf0 \cb3     \cf7 \strokec7 # Constants for adaptive control\cf0 \cb1 \strokec4 \
\cb3     MIN_DISTANCE = \cf8 \strokec8 10\cf7 \strokec7 # cm - threshold for short movements\cf0 \cb1 \strokec4 \
\cb3     MEDIUM_DISTANCE = \cf8 \strokec8 50\cf7 \strokec7 # cm - threshold for medium movements\cf0 \cb1 \strokec4 \
\cb3     HIGH_SPEED = \cf8 \strokec8 70\cf7 \strokec7 # threshold for high speed movements\cf0 \cb1 \strokec4 \
\
\cb3     \cf7 \strokec7 # Calculate adaptive factors based on distance and speed\cf0 \cb1 \strokec4 \
\cb3     abs_distance = \cf2 \strokec2 abs\cf5 \strokec5 (\cf0 \strokec4 target_distance\cf5 \strokec5 )\cf0 \cb1 \strokec4 \
\cb3     abs_speed = \cf2 \strokec2 abs\cf5 \strokec5 (\cf0 \strokec4 max_speed\cf5 \strokec5 )\cf0 \cb1 \strokec4 \
\
\cb3     \cf7 \strokec7 # Base factors adjusted by distance\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 if\cf0 \strokec4  abs_distance < MIN_DISTANCE:\cb1 \
\cb3         \cf7 \strokec7 # Short distance: prioritize precision\cf0 \cb1 \strokec4 \
\cb3         base_accel = \cf8 \strokec8 0.35\cf0 \cb1 \strokec4 \
\cb3         base_decel = \cf8 \strokec8 0.35\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 elif\cf0 \strokec4  abs_distance < MEDIUM_DISTANCE:\cb1 \
\cb3         \cf7 \strokec7 # Medium distance: balanced approach\cf0 \cb1 \strokec4 \
\cb3         base_accel = \cf8 \strokec8 0.25\cf0 \cb1 \strokec4 \
\cb3         base_decel = \cf8 \strokec8 0.3\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 else\cf0 \strokec4 :\cb1 \
\cb3         \cf7 \strokec7 # Long distance: prioritize speed\cf0 \cb1 \strokec4 \
\cb3         base_accel = \cf8 \strokec8 0.15\cf0 \cb1 \strokec4 \
\cb3         base_decel = \cf8 \strokec8 0.2\cf0 \cb1 \strokec4 \
\
\cb3     \cf7 \strokec7 # Adjust factors based on speed\cf0 \cb1 \strokec4 \
\cb3     speed_factor = abs_speed / \cf8 \strokec8 100.0\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 if\cf0 \strokec4  abs_speed > HIGH_SPEED:\cb1 \
\cb3         \cf7 \strokec7 # High speed: increase acceleration distance for smoothness\cf0 \cb1 \strokec4 \
\cb3         accel_factor = base_accel * \cf5 \strokec5 (\cf8 \strokec8 1\cf0 \strokec4  + \cf8 \strokec8 0.5\cf0 \strokec4  * speed_factor\cf5 \strokec5 )\cf0 \cb1 \strokec4 \
\cb3         decel_factor = base_decel * \cf5 \strokec5 (\cf8 \strokec8 1\cf0 \strokec4  + \cf8 \strokec8 0.7\cf0 \strokec4  * speed_factor\cf5 \strokec5 )\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 else\cf0 \strokec4 :\cb1 \
\cb3         \cf7 \strokec7 # Lower speed: maintain base factors\cf0 \cb1 \strokec4 \
\cb3         accel_factor = base_accel\cb1 \
\cb3         decel_factor = base_decel\cb1 \
\
\cb3     \cf7 \strokec7 # Calculate actual distances while ensuring minimums\cf0 \cb1 \strokec4 \
\cb3     accel_distance = \cf2 \strokec2 max\cf5 \strokec5 (\cf0 \strokec4 abs_distance * accel_factor, \cf8 \strokec8 5\cf5 \strokec5 )\cf7 \strokec7 # minimum 5cm\cf0 \cb1 \strokec4 \
\cb3     decel_distance = \cf2 \strokec2 max\cf5 \strokec5 (\cf0 \strokec4 abs_distance * decel_factor, \cf8 \strokec8 5\cf5 \strokec5 )\cf7 \strokec7 # minimum 5cm\cf0 \cb1 \strokec4 \
\
\cb3     \cf7 \strokec7 # Adjust for very short distances\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 if\cf0 \strokec4  abs_distance < \cf5 \strokec5 (\cf0 \strokec4 accel_distance + decel_distance\cf5 \strokec5 )\cf0 \strokec4 :\cb1 \
\cb3         total_factor = accel_distance + decel_distance\cb1 \
\cb3         accel_distance = abs_distance * \cf5 \strokec5 (\cf0 \strokec4 accel_distance / total_factor\cf5 \strokec5 )\cf0 \cb1 \strokec4 \
\cb3         decel_distance = abs_distance * \cf5 \strokec5 (\cf0 \strokec4 decel_distance / total_factor\cf5 \strokec5 )\cf0 \cb1 \strokec4 \
\
\cb3     \cf7 \strokec7 # Adjust kp direction based on speed direction\cf0 \cb1 \strokec4 \
\cb3     \cf2 \strokec2 if\cf0 \strokec4  \cf5 \strokec5 (\cf0 \strokec4 max_speed < \cf8 \strokec8 0\cf5 \strokec5 )\cf0 \strokec4 :\cb1 \
\cb3         kp = -kp\cb1 \
\
\cb3     \cf7 \strokec7 # Get movement direction (1 or -1)\cf0 \cb1 \strokec4 \
\cb3     direction = \cf2 \strokec2 int\cf5 \strokec5 (\cf0 \strokec4 max_speed/\cf2 \strokec2 abs\cf5 \strokec5 (\cf0 \strokec4 max_speed\cf5 \strokec5 ))\cf0 \cb1 \strokec4 \
\
\cb3     \cf7 \strokec7 # Reset encoder\cf0 \cb1 \strokec4 \
\cb3     LeftMotor.set_degrees_counted\cf5 \strokec5 (\cf8 \strokec8 0\cf5 \strokec5 )\cf0 \cb1 \strokec4 \
\
\cb3     \cf7 \strokec7 # Get initial position\cf0 \cb1 \strokec4 \
\cb3     current_position = LeftMotor.get_degrees_counted\cf5 \strokec5 ()\cf0 \strokec4  / \cf8 \strokec8 360\cf0 \strokec4  * WHEEL_DIAMETER * \cf8 \strokec8 3.141592\cf0 \cb1 \strokec4 \
\
\cb3     \cf7 \strokec7 # Calculate minimum speed (adaptive based on distance)\cf0 \cb1 \strokec4 \
\cb3     min_speed_factor = \cf2 \strokec2 min\cf5 \strokec5 (\cf8 \strokec8 0.3\cf0 \strokec4 , \cf8 \strokec8 3\cf0 \strokec4  / abs_distance\cf5 \strokec5 )\cf0 \strokec4  \cf2 \strokec2 if\cf0 \strokec4  abs_distance > \cf8 \strokec8 10\cf0 \strokec4  \cf2 \strokec2 else\cf0 \strokec4  \cf8 \strokec8 0.3\cf0 \cb1 \strokec4 \
\cb3     MIN_SPEED = \cf2 \strokec2 max\cf5 \strokec5 (\cf8 \strokec8 15\cf0 \strokec4 , abs_speed * min_speed_factor\cf5 \strokec5 )\cf0 \strokec4  * direction\cb1 \
\
\cb3     \cf7 \strokec7 # Previous speed for smoothing\cf0 \cb1 \strokec4 \
\cb3     prev_speed = MIN_SPEED\cb1 \
\
\cb3     \cf2 \strokec2 while\cf0 \strokec4  \cf2 \strokec2 abs\cf5 \strokec5 (\cf0 \strokec4 current_position\cf5 \strokec5 )\cf0 \strokec4  < \cf2 \strokec2 abs\cf5 \strokec5 (\cf0 \strokec4 target_distance\cf5 \strokec5 )\cf0 \strokec4 :\cb1 \
\cb3         \cf7 \strokec7 # Calculate remaining distance\cf0 \cb1 \strokec4 \
\cb3         remaining_distance = \cf2 \strokec2 abs\cf5 \strokec5 (\cf0 \strokec4 target_distance\cf5 \strokec5 )\cf0 \strokec4  - \cf2 \strokec2 abs\cf5 \strokec5 (\cf0 \strokec4 current_position\cf5 \strokec5 )\cf0 \cb1 \strokec4 \
\
\cb3         \cf7 \strokec7 # Calculate base speed based on position\cf0 \cb1 \strokec4 \
\cb3         \cf2 \strokec2 if\cf0 \strokec4  \cf2 \strokec2 abs\cf5 \strokec5 (\cf0 \strokec4 current_position\cf5 \strokec5 )\cf0 \strokec4  < accel_distance:\cb1 \
\cb3             \cf7 \strokec7 # Accelerating - smooth quadratic acceleration\cf0 \cb1 \strokec4 \
\cb3             progress = \cf2 \strokec2 abs\cf5 \strokec5 (\cf0 \strokec4 current_position\cf5 \strokec5 )\cf0 \strokec4  / accel_distance\cb1 \
\cb3             speed_factor = progress * \cf5 \strokec5 (\cf8 \strokec8 2\cf0 \strokec4  - progress\cf5 \strokec5 )\cf7 \strokec7 # quadratic easing\cf0 \cb1 \strokec4 \
\cb3             current_speed = MIN_SPEED + \cf5 \strokec5 (\cf0 \strokec4 max_speed - MIN_SPEED\cf5 \strokec5 )\cf0 \strokec4  * speed_factor\cb1 \
\
\cb3         \cf2 \strokec2 elif\cf0 \strokec4  remaining_distance < decel_distance:\cb1 \
\cb3             \cf7 \strokec7 # Decelerating - smooth quadratic deceleration\cf0 \cb1 \strokec4 \
\cb3             progress = remaining_distance / decel_distance\cb1 \
\cb3             speed_factor = progress * \cf5 \strokec5 (\cf8 \strokec8 2\cf0 \strokec4  - progress\cf5 \strokec5 )\cf7 \strokec7 # quadratic easing\cf0 \cb1 \strokec4 \
\cb3             current_speed = MIN_SPEED + \cf5 \strokec5 (\cf0 \strokec4 max_speed - MIN_SPEED\cf5 \strokec5 )\cf0 \strokec4  * speed_factor\cb1 \
\
\cb3         \cf2 \strokec2 else\cf0 \strokec4 :\cb1 \
\cb3             \cf7 \strokec7 # Full speed\cf0 \cb1 \strokec4 \
\cb3             current_speed = max_speed\cb1 \
\
\cb3         \cf7 \strokec7 # Smooth speed changes\cf0 \cb1 \strokec4 \
\cb3         smoothing_factor = \cf8 \strokec8 0.7\cf0 \cb1 \strokec4 \
\cb3         current_speed = \cf5 \strokec5 (\cf0 \strokec4 current_speed * smoothing_factor +\cb1 \
\cb3                         prev_speed * \cf5 \strokec5 (\cf8 \strokec8 1\cf0 \strokec4  - smoothing_factor\cf5 \strokec5 ))\cf0 \cb1 \strokec4 \
\cb3         prev_speed = current_speed\cb1 \
\
\cb3         \cf7 \strokec7 # Calculate heading correction\cf0 \cb1 \strokec4 \
\cb3         heading_error = target_heading - hub.motion_sensor.get_yaw_angle\cf5 \strokec5 ()\cf0 \cb1 \strokec4 \
\
\cb3         \cf7 \strokec7 # Apply heading correction with adaptive kp\cf0 \cb1 \strokec4 \
\cb3         \cf7 \strokec7 # Reduce kp at higher speeds for stability\cf0 \cb1 \strokec4 \
\cb3         adaptive_kp = kp * \cf5 \strokec5 (\cf8 \strokec8 1\cf0 \strokec4  - \cf8 \strokec8 0.3\cf0 \strokec4  * \cf5 \strokec5 (\cf2 \strokec2 abs\cf5 \strokec5 (\cf0 \strokec4 current_speed\cf5 \strokec5 )\cf0 \strokec4  / \cf8 \strokec8 100\cf5 \strokec5 ))\cf0 \cb1 \strokec4 \
\
\cb3         \cf7 \strokec7 # Apply heading correction\cf0 \cb1 \strokec4 \
\cb3         right_speed = \cf2 \strokec2 int\cf5 \strokec5 (\cf0 \strokec4 current_speed - heading_error * adaptive_kp * direction\cf5 \strokec5 )\cf0 \cb1 \strokec4 \
\cb3         left_speed = \cf2 \strokec2 int\cf5 \strokec5 (\cf0 \strokec4 current_speed + heading_error * adaptive_kp * direction\cf5 \strokec5 )\cf0 \cb1 \strokec4 \
\
\cb3         \cf7 \strokec7 # Drive motors\cf0 \cb1 \strokec4 \
\cb3         drive_base.start_tank\cf5 \strokec5 (\cf0 \strokec4 left_speed, right_speed\cf5 \strokec5 )\cf0 \cb1 \strokec4 \
\
\cb3         \cf7 \strokec7 # Update position\cf0 \cb1 \strokec4 \
\cb3         current_position = LeftMotor.get_degrees_counted\cf5 \strokec5 ()\cf0 \strokec4  / \cf8 \strokec8 360\cf0 \strokec4  * WHEEL_DIAMETER * \cf8 \strokec8 3.141592\cf0 \cb1 \strokec4 \
\
\cb3     \cf7 \strokec7 # Stop motors\cf0 \cb1 \strokec4 \
\cb3     drive_base.stop\cf5 \strokec5 ()\cf0 \cb1 \strokec4 \
\
\
\
\pard\pardeftab720\partightenfactor0
\cf7 \cb3 \strokec7 #go: cm/time; speed; heading; kp = 1.5\cf0 \cb1 \strokec4 \
\cf7 \cb3 \strokec7 #turn: angle; speed; error = 0\cf0 \cb1 \strokec4 \
\
\cf7 \cb3 \strokec7 #start from left_launch\cf0 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf0 \cb3 hub.motion_sensor.reset_yaw_angle\cf5 \strokec5 ()\cf0 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf7 \cb3 \strokec7 # #open the arm\cf0 \cb1 \strokec4 \
\cf7 \cb3 \strokec7 # arm.run_for_degrees(100,30)\cf0 \cb1 \strokec4 \
\
\cf7 \cb3 \strokec7 # turn(33,30)\cf0 \cb1 \strokec4 \
\cf7 \cb3 \strokec7 # arm.run_for_degrees(80,30)\cf0 \cb1 \strokec4 \
\
\cf7 \cb3 \strokec7 # go (10,-25,-33)\cf0 \cb1 \strokec4 \
\
\
\pard\pardeftab720\partightenfactor0
\cf0 \cb3 go\cf5 \strokec5 (\cf8 \strokec8 18\cf0 \strokec4 ,\cf8 \strokec8 40\cf0 \strokec4 ,\cf8 \strokec8 0\cf5 \strokec5 )\cf0 \cb1 \strokec4 \
\cb3 turn\cf5 \strokec5 (\cf8 \strokec8 45\cf0 \strokec4 ,\cf8 \strokec8 25\cf5 \strokec5 )\cf0 \cb1 \strokec4 \
\cb3 go\cf5 \strokec5 (\cf8 \strokec8 30\cf0 \strokec4 ,\cf8 \strokec8 40\cf0 \strokec4 ,\cf8 \strokec8 45\cf5 \strokec5 )\cf0 \cb1 \strokec4 \
\cb3 go\cf5 \strokec5 (\cf8 \strokec8 10\cf0 \strokec4 ,\cf8 \strokec8 -25\cf0 \strokec4 ,\cf8 \strokec8 45\cf5 \strokec5 )\cf0 \cb1 \strokec4 \
\cb3 turn \cf5 \strokec5 (\cf8 \strokec8 90\cf0 \strokec4 ,\cf8 \strokec8 25\cf5 \strokec5 )\cf0 \cb1 \strokec4 \
\cb3 go\cf5 \strokec5 (\cf8 \strokec8 16\cf0 \strokec4 ,\cf8 \strokec8 25\cf0 \strokec4 ,\cf8 \strokec8 90\cf5 \strokec5 )\cf0 \cb1 \strokec4 \
\
\
\cb3 arm.run_for_degrees\cf5 \strokec5 (\cf8 \strokec8 110\cf0 \strokec4 ,\cf8 \strokec8 30\cf5 \strokec5 )\cf0 \cb1 \strokec4 \
\cb3 turn\cf5 \strokec5 (\cf8 \strokec8 35\cf0 \strokec4 ,\cf8 \strokec8 35\cf5 \strokec5 )\cf0 \cb1 \strokec4 \
\cb3 arm.run_for_degrees\cf5 \strokec5 (\cf8 \strokec8 -110\cf0 \strokec4 ,\cf8 \strokec8 30\cf5 \strokec5 )\cf0 \cb1 \strokec4 \
\cb3 go \cf5 \strokec5 (\cf8 \strokec8 5\cf0 \strokec4 ,\cf8 \strokec8 -75\cf0 \strokec4 ,\cf8 \strokec8 35\cf5 \strokec5 )\cf0 \cb1 \strokec4 \
\cb3 turn\cf5 \strokec5 (\cf8 \strokec8 80\cf0 \strokec4 ,\cf8 \strokec8 100\cf5 \strokec5 )\cf0 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf7 \cb3 \strokec7 # go (38,75,80)\cf0 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf0 \cb3 drive_base.move_tank\cf5 \strokec5 (\cf8 \strokec8 50\cf0 \strokec4 ,\cf6 \strokec6 'cm'\cf0 \strokec4 ,\cf8 \strokec8 100\cf0 \strokec4 ,\cf8 \strokec8 100\cf5 \strokec5 )\cf0 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 raise\cf0 \strokec4  SystemExit\cb1 \
\
\
}