{\rtf1\ansi\ansicpg1252\cocoartf2818
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red12\green98\blue192;\red255\green255\blue254;\red0\green0\blue0;
\red15\green118\blue104;\red204\green0\blue137;\red18\green135\blue47;\red252\green103\blue8;}
{\*\expandedcolortbl;;\cssrgb\c0\c47059\c80000;\cssrgb\c100000\c100000\c99608;\cssrgb\c0\c0\c0;
\cssrgb\c0\c52941\c48235;\cssrgb\c84706\c0\c60784;\cssrgb\c0\c58824\c24314;\cssrgb\c100000\c49020\c0;}
\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs29\fsmilli14900 \cf2 \cb3 \expnd0\expndtw0\kerning0
from\cf0  spike \cf2 import\cf0  PrimeHub, LightMatrix, Button, StatusLight, ForceSensor, MotionSensor, Speaker, ColorSensor, App, DistanceSensor, Motor, MotorPair\cb1 \
\cf2 \cb3 from\cf0  spike.control \cf2 import\cf0  wait_for_seconds, wait_until, Timer\cb1 \
\cf2 \cb3 from\cf0  math \cf2 import\cf0  *\cb1 \
\
\cb3 hub = PrimeHub\cf5 ()\cf0 \cb1 \
\cb3 drive_base = MotorPair\cf5 (\cf6 'C'\cf0 , \cf6 'F'\cf5 )\cf0 \cb1 \
\cb3 LeftMotor = Motor\cf5 (\cf6 'C'\cf5 )\cf0 \cb1 \
\cb3 RightMotor = Motor\cf5 (\cf6 'F'\cf5 )\cf0 \cb1 \
\cb3 tail = Motor\cf5 (\cf6 'A'\cf5 )\cf0 \cb1 \
\cb3 arm = Motor\cf5 (\cf6 'E'\cf5 )\cf0 \cb1 \
\pard\pardeftab720\partightenfactor0
\cf7 \cb3 # r_col = ColorSensor('D')\cf0 \cb1 \
\pard\pardeftab720\partightenfactor0
\cf0 \cb3 l_col = ColorSensor\cf5 (\cf6 'B'\cf5 )\cf0 \cb1 \
\cb3 timer = Timer\cf5 ()\cf0 \cb1 \
\cb3 WHEEL_DIAMETER = \cf8 5.6\cf0  \cf7 # small spike wheel in cm\cf0 \cb1 \
\cb3 drive_base.set_stop_action\cf5 (\cf6 'brake'\cf5 )\cf0 \cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf6 \cb3 '''\cf0 \cb1 \
\cf6 \cb3 Turns the robot left or right as long as the angle is not larger than 180\cf0 \cb1 \
\cf6 \cb3 Angle is relative to current robot heading (resets heading prior to turning)\cf0 \cb1 \
\cf6 \cb3 '''\cf0 \cb1 \
\
\
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 def\cf0  turn\cf5 (\cf0 target_heading, speed, momentum_error=\cf8 0\cf5 )\cf0 :\cb1 \
\cb3     \cf7 # speed must be positive\cf0 \cb1 \
\cb3     speed = \cf2 abs\cf5 (\cf0 speed\cf5 )\cf0 \cb1 \
\
\cb3     \cf7 # reset yaw angle to 0\cf0 \cb1 \
\cb3     hub.motion_sensor.reset_yaw_angle\cf5 ()\cf0 \cb1 \
\
\cb3     \cf7 # get initial robot heading\cf0 \cb1 \
\cb3     robot_heading = hub.motion_sensor.get_yaw_angle\cf5 ()\cf0 \cb1 \
\
\cb3     \cf7 # keep turning until goal is reached while accounting for potential momentum error\cf0 \cb1 \
\cb3     \cf2 while\cf0  \cf2 abs\cf5 (\cf0 robot_heading\cf5 )\cf0  < \cf5 (\cf2 abs\cf5 (\cf0 target_heading\cf5 )\cf0  - momentum_error\cf5 )\cf0 :\cb1 \
\cb3         \cf7 # Calculate the remaining angle to the target\cf0 \cb1 \
\cb3         remaining_angle = \cf2 abs\cf5 (\cf0 target_heading\cf5 )\cf0  - \cf2 abs\cf5 (\cf0 robot_heading\cf5 )\cf0 \cb1 \
\
\cb3         \cf7 # Apply a simple deceleration based on the remaining angle\cf0 \cb1 \
\cb3         deceleration_factor = \cf2 max\cf5 (\cf8 0.24\cf0 , \cf2 min\cf5 (\cf8 1\cf0 , remaining_angle / \cf2 abs\cf5 (\cf0 target_heading\cf5 )))\cf0 \cb1 \
\cb3         adjusted_speed = \cf2 int\cf5 (\cf0 speed * deceleration_factor\cf5 )\cf0 \cb1 \
\
\cb3         \cf7 # Turns the robot left or right depending on the target heading sign (positive or negative)\cf0 \cb1 \
\cb3         right_speed = -adjusted_speed * \cf2 int\cf5 (\cf0 target_heading / \cf2 abs\cf5 (\cf0 target_heading\cf5 ))\cf0 \cb1 \
\cb3         left_speed = adjusted_speed * \cf2 int\cf5 (\cf0 target_heading / \cf2 abs\cf5 (\cf0 target_heading\cf5 ))\cf0 \cb1 \
\
\cb3         \cf7 # Start turning\cf0 \cb1 \
\cb3         drive_base.start_tank\cf5 (\cf0 left_speed, right_speed\cf5 )\cf0 \cb1 \
\
\cb3         \cf7 # Update heading measurement\cf0 \cb1 \
\cb3         robot_heading = hub.motion_sensor.get_yaw_angle\cf5 ()\cf0 \cb1 \
\
\cb3     \cf7 # Stop turning\cf0 \cb1 \
\cb3     drive_base.stop\cf5 ()\cf0 \cb1 \
\
\
\
\cf2 \cb3 def\cf0  go\cf5 (\cf0 target_distance, max_speed, target_heading, kp=\cf8 1.0\cf5 )\cf0 :\cb1 \
\cb3     \cf6 """\cf0 \cb1 \
\pard\pardeftab720\partightenfactor0
\cf6 \cb3     Move robot straight with adaptive acceleration and deceleration\cf0 \cb1 \
\cf6 \cb3     Automatically balances speed and precision based on distance and speed\cf0 \cb1 \
\cf6 \cb3     Args:\cf0 \cb1 \
\cf6 \cb3         target_distance: distance to travel in cm\cf0 \cb1 \
\cf6 \cb3         max_speed: maximum speed (-100 to 100, negative for backward)\cf0 \cb1 \
\cf6 \cb3         target_heading: target heading angle in degrees\cf0 \cb1 \
\cf6 \cb3         kp: proportional gain for heading correction\cf0 \cb1 \
\cf6 \cb3     """\cf0 \cb1 \
\pard\pardeftab720\partightenfactor0
\cf0 \cb3     \cf7 # Constants for adaptive control\cf0 \cb1 \
\cb3     MIN_DISTANCE = \cf8 10\cf7 # cm - threshold for short movements\cf0 \cb1 \
\cb3     MEDIUM_DISTANCE = \cf8 50\cf7 # cm - threshold for medium movements\cf0 \cb1 \
\cb3     HIGH_SPEED = \cf8 70\cf7 # threshold for high speed movements\cf0 \cb1 \
\
\cb3     \cf7 # Calculate adaptive factors based on distance and speed\cf0 \cb1 \
\cb3     abs_distance = \cf2 abs\cf5 (\cf0 target_distance\cf5 )\cf0 \cb1 \
\cb3     abs_speed = \cf2 abs\cf5 (\cf0 max_speed\cf5 )\cf0 \cb1 \
\
\cb3     \cf7 # Base factors adjusted by distance\cf0 \cb1 \
\cb3     \cf2 if\cf0  abs_distance < MIN_DISTANCE:\cb1 \
\cb3         \cf7 # Short distance: prioritize precision\cf0 \cb1 \
\cb3         base_accel = \cf8 0.35\cf0 \cb1 \
\cb3         base_decel = \cf8 0.35\cf0 \cb1 \
\cb3     \cf2 elif\cf0  abs_distance < MEDIUM_DISTANCE:\cb1 \
\cb3         \cf7 # Medium distance: balanced approach\cf0 \cb1 \
\cb3         base_accel = \cf8 0.25\cf0 \cb1 \
\cb3         base_decel = \cf8 0.3\cf0 \cb1 \
\cb3     \cf2 else\cf0 :\cb1 \
\cb3         \cf7 # Long distance: prioritize speed\cf0 \cb1 \
\cb3         base_accel = \cf8 0.15\cf0 \cb1 \
\cb3         base_decel = \cf8 0.2\cf0 \cb1 \
\
\cb3     \cf7 # Adjust factors based on speed\cf0 \cb1 \
\cb3     speed_factor = abs_speed / \cf8 100.0\cf0 \cb1 \
\cb3     \cf2 if\cf0  abs_speed > HIGH_SPEED:\cb1 \
\cb3         \cf7 # High speed: increase acceleration distance for smoothness\cf0 \cb1 \
\cb3         accel_factor = base_accel * \cf5 (\cf8 1\cf0  + \cf8 0.5\cf0  * speed_factor\cf5 )\cf0 \cb1 \
\cb3         decel_factor = base_decel * \cf5 (\cf8 1\cf0  + \cf8 0.7\cf0  * speed_factor\cf5 )\cf0 \cb1 \
\cb3     \cf2 else\cf0 :\cb1 \
\cb3         \cf7 # Lower speed: maintain base factors\cf0 \cb1 \
\cb3         accel_factor = base_accel\cb1 \
\cb3         decel_factor = base_decel\cb1 \
\
\cb3     \cf7 # Calculate actual distances while ensuring minimums\cf0 \cb1 \
\cb3     accel_distance = \cf2 max\cf5 (\cf0 abs_distance * accel_factor, \cf8 5\cf5 )\cf7 # minimum 5cm\cf0 \cb1 \
\cb3     decel_distance = \cf2 max\cf5 (\cf0 abs_distance * decel_factor, \cf8 5\cf5 )\cf7 # minimum 5cm\cf0 \cb1 \
\
\cb3     \cf7 # Adjust for very short distances\cf0 \cb1 \
\cb3     \cf2 if\cf0  abs_distance < \cf5 (\cf0 accel_distance + decel_distance\cf5 )\cf0 :\cb1 \
\cb3         total_factor = accel_distance + decel_distance\cb1 \
\cb3         accel_distance = abs_distance * \cf5 (\cf0 accel_distance / total_factor\cf5 )\cf0 \cb1 \
\cb3         decel_distance = abs_distance * \cf5 (\cf0 decel_distance / total_factor\cf5 )\cf0 \cb1 \
\
\cb3     \cf7 # Adjust kp direction based on speed direction\cf0 \cb1 \
\cb3     \cf2 if\cf0  \cf5 (\cf0 max_speed < \cf8 0\cf5 )\cf0 :\cb1 \
\cb3         kp = -kp\cb1 \
\
\cb3     \cf7 # Get movement direction (1 or -1)\cf0 \cb1 \
\cb3     direction = \cf2 int\cf5 (\cf0 max_speed/\cf2 abs\cf5 (\cf0 max_speed\cf5 ))\cf0 \cb1 \
\
\cb3     \cf7 # Reset encoder\cf0 \cb1 \
\cb3     LeftMotor.set_degrees_counted\cf5 (\cf8 0\cf5 )\cf0 \cb1 \
\
\cb3     \cf7 # Get initial position\cf0 \cb1 \
\cb3     current_position = LeftMotor.get_degrees_counted\cf5 ()\cf0  / \cf8 360\cf0  * WHEEL_DIAMETER * \cf8 3.141592\cf0 \cb1 \
\
\cb3     \cf7 # Calculate minimum speed (adaptive based on distance)\cf0 \cb1 \
\cb3     min_speed_factor = \cf2 min\cf5 (\cf8 0.3\cf0 , \cf8 3\cf0  / abs_distance\cf5 )\cf0  \cf2 if\cf0  abs_distance > \cf8 10\cf0  \cf2 else\cf0  \cf8 0.3\cf0 \cb1 \
\cb3     MIN_SPEED = \cf2 max\cf5 (\cf8 15\cf0 , abs_speed * min_speed_factor\cf5 )\cf0  * direction\cb1 \
\
\cb3     \cf7 # Previous speed for smoothing\cf0 \cb1 \
\cb3     prev_speed = MIN_SPEED\cb1 \
\
\cb3     \cf2 while\cf0  \cf2 abs\cf5 (\cf0 current_position\cf5 )\cf0  < \cf2 abs\cf5 (\cf0 target_distance\cf5 )\cf0 :\cb1 \
\cb3         \cf7 # Calculate remaining distance\cf0 \cb1 \
\cb3         remaining_distance = \cf2 abs\cf5 (\cf0 target_distance\cf5 )\cf0  - \cf2 abs\cf5 (\cf0 current_position\cf5 )\cf0 \cb1 \
\
\cb3         \cf7 # Calculate base speed based on position\cf0 \cb1 \
\cb3         \cf2 if\cf0  \cf2 abs\cf5 (\cf0 current_position\cf5 )\cf0  < accel_distance:\cb1 \
\cb3             \cf7 # Accelerating - smooth quadratic acceleration\cf0 \cb1 \
\cb3             progress = \cf2 abs\cf5 (\cf0 current_position\cf5 )\cf0  / accel_distance\cb1 \
\cb3             speed_factor = progress * \cf5 (\cf8 2\cf0  - progress\cf5 )\cf7 # quadratic easing\cf0 \cb1 \
\cb3             current_speed = MIN_SPEED + \cf5 (\cf0 max_speed - MIN_SPEED\cf5 )\cf0  * speed_factor\cb1 \
\
\cb3         \cf2 elif\cf0  remaining_distance < decel_distance:\cb1 \
\cb3             \cf7 # Decelerating - smooth quadratic deceleration\cf0 \cb1 \
\cb3             progress = remaining_distance / decel_distance\cb1 \
\cb3             speed_factor = progress * \cf5 (\cf8 2\cf0  - progress\cf5 )\cf7 # quadratic easing\cf0 \cb1 \
\cb3             current_speed = MIN_SPEED + \cf5 (\cf0 max_speed - MIN_SPEED\cf5 )\cf0  * speed_factor\cb1 \
\
\cb3         \cf2 else\cf0 :\cb1 \
\cb3             \cf7 # Full speed\cf0 \cb1 \
\cb3             current_speed = max_speed\cb1 \
\
\cb3         \cf7 # Smooth speed changes\cf0 \cb1 \
\cb3         smoothing_factor = \cf8 0.7\cf0 \cb1 \
\cb3         current_speed = \cf5 (\cf0 current_speed * smoothing_factor +\cb1 \
\cb3                         prev_speed * \cf5 (\cf8 1\cf0  - smoothing_factor\cf5 ))\cf0 \cb1 \
\cb3         prev_speed = current_speed\cb1 \
\
\cb3         \cf7 # Calculate heading correction\cf0 \cb1 \
\cb3         heading_error = target_heading - hub.motion_sensor.get_yaw_angle\cf5 ()\cf0 \cb1 \
\
\cb3         \cf7 # Apply heading correction with adaptive kp\cf0 \cb1 \
\cb3         \cf7 # Reduce kp at higher speeds for stability\cf0 \cb1 \
\cb3         adaptive_kp = kp * \cf5 (\cf8 1\cf0  - \cf8 0.3\cf0  * \cf5 (\cf2 abs\cf5 (\cf0 current_speed\cf5 )\cf0  / \cf8 100\cf5 ))\cf0 \cb1 \
\
\cb3         \cf7 # Apply heading correction\cf0 \cb1 \
\cb3         right_speed = \cf2 int\cf5 (\cf0 current_speed - heading_error * adaptive_kp * direction\cf5 )\cf0 \cb1 \
\cb3         left_speed = \cf2 int\cf5 (\cf0 current_speed + heading_error * adaptive_kp * direction\cf5 )\cf0 \cb1 \
\
\cb3         \cf7 # Drive motors\cf0 \cb1 \
\cb3         drive_base.start_tank\cf5 (\cf0 left_speed, right_speed\cf5 )\cf0 \cb1 \
\
\cb3         \cf7 # Update position\cf0 \cb1 \
\cb3         current_position = LeftMotor.get_degrees_counted\cf5 ()\cf0  / \cf8 360\cf0  * WHEEL_DIAMETER * \cf8 3.141592\cf0 \cb1 \
\
\cb3     \cf7 # Stop motors\cf0 \cb1 \
\cb3     drive_base.stop\cf5 ()\cf0 \cb1 \
\
\
\
\pard\pardeftab720\partightenfactor0
\cf7 \cb3 #go: cm/time; speed; heading; kp = 1.5\cf0 \cb1 \
\cf7 \cb3 #turn: angle; speed; error = 0\cf0 \cb1 \
\
\cf7 \cb3 #start from left_launch\cf0 \cb1 \
\pard\pardeftab720\partightenfactor0
\cf0 \cb3 hub.motion_sensor.reset_yaw_angle\cf5 ()\cf0 \cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf7 \cb3 #open the arm\cf0 \cb1 \
\pard\pardeftab720\partightenfactor0
\cf0 \cb3 arm.run_for_degrees\cf5 (\cf8 120\cf0 ,\cf8 30\cf5 )\cf0 \cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf7 \cb3 #extend arm\cf0 \cb1 \
\cf7 \cb3 # tail.run_for_degrees(-800,80)\cf0 \cb1 \
\cf7 \cb3 # tail.run_for_degrees(240,30)\cf0 \cb1 \
\
\
\cf7 \cb3 #### Mission 01 Coral Nursery\cf0 \cb1 \
\pard\pardeftab720\partightenfactor0
\cf0 \cb3 go\cf5 (\cf8 70\cf0 , \cf8 50\cf0 , \cf8 0\cf5 )\cf0 \cb1 \
\cb3 turn\cf5 (\cf8 90\cf0 , \cf8 30\cf5 )\cf0 \cb1 \
\cb3 go\cf5 (\cf8 15\cf0 , \cf8 -40\cf0 , \cf8 90\cf5 )\cf0 \cb1 \
\pard\pardeftab720\partightenfactor0
\cf7 \cb3 #################\cf0 \cb1 \
\
\cf7 \cb3 ## Mission 02 Shark\cf0 \cb1 \
\pard\pardeftab720\partightenfactor0
\cf0 \cb3 go\cf5 (\cf8 15\cf0 , \cf8 40\cf0 , \cf8 90\cf5 )\cf0 \cb1 \
\cb3 turn\cf5 (\cf8 -133\cf0 ,\cf8 35\cf5 )\cf0 \cb1 \
\cb3 go\cf5 (\cf8 17\cf0 , \cf8 25\cf0 , \cf8 -133\cf5 )\cf0 \cb1 \
\cb3 arm.run_for_degrees\cf5 (\cf8 -120\cf0 ,\cf8 30\cf5 )\cf0 \cb1 \
\cb3 wait_for_seconds\cf5 (\cf8 0.1\cf5 )\cf0 \cb1 \
\cb3 arm.run_for_degrees\cf5 (\cf8 120\cf0 ,\cf8 30\cf5 )\cf0 \cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf7 \cb3 ## Mission 04 scuba diver\cf0 \cb1 \
\pard\pardeftab720\partightenfactor0
\cf0 \cb3 go\cf5 (\cf8 8\cf0 , \cf8 -25\cf0 , \cf8 -133\cf5 )\cf0 \cb1 \
\cb3 turn\cf5 (\cf8 -47\cf0 ,\cf8 25\cf5 )\cf0 \cb1 \
\cb3 tail.run_for_degrees\cf5 (\cf8 -530\cf0 ,\cf8 49\cf5 )\cf0 \cb1 \
\cb3 go\cf5 (\cf8 8\cf0 , \cf8 25\cf0 , \cf8 -47\cf5 )\cf0 \cb1 \
\cb3 tail.run_for_degrees\cf5 (\cf8 130\cf0 ,\cf8 80\cf5 )\cf0 \cb1 \
\cb3 wait_for_seconds\cf5 (\cf8 0.2\cf5 )\cf0 \cb1 \
\
\
\pard\pardeftab720\partightenfactor0
\cf7 \cb3 ## Mission 03 Coral reefs\cf0 \cb1 \
\pard\pardeftab720\partightenfactor0
\cf0 \cb3 go\cf5 (\cf8 3\cf0 , \cf8 -35\cf0 , \cf8 -45\cf5 )\cf0 \cb1 \
\cb3 turn\cf5 (\cf8 85\cf0 ,\cf8 20\cf0 ,\cf8 2\cf5 )\cf0 \cb1 \
\cb3 arm.run_for_degrees\cf5 (\cf8 -120\cf0 ,\cf8 30\cf5 )\cf0 \cb1 \
\cb3 go\cf5 (\cf8 17\cf0 , \cf8 25\cf0 , \cf8 85\cf5 )\cf0 \cb1 \
\cb3 turn\cf5 (\cf8 90\cf0 ,\cf8 25\cf5 )\cf0 \cb1 \
\cb3 go\cf5 (\cf8 1.5\cf0 , \cf8 25\cf0 , \cf8 90\cf5 )\cf0 \cb1 \
\cb3 turn \cf5 (\cf8 -18\cf0 ,\cf8 25\cf5 )\cf0 \cb1 \
\cb3 tail.run_for_degrees\cf5 (\cf8 -650\cf0 ,\cf8 50\cf5 )\cf0 \cb1 \
\cb3 wait_for_seconds\cf5 (\cf8 0.1\cf5 )\cf0 \cb1 \
\cb3 go\cf5 (\cf8 2\cf0 , \cf8 -50\cf0 , \cf8 -18\cf5 )\cf0 \cb1 \
\
\cb3 tail.run_for_degrees\cf5 (\cf8 670\cf0 ,\cf8 90\cf5 )\cf0 \cb1 \
\
\cb3 turn\cf5 (\cf8 -80\cf0 ,\cf8 25\cf5 )\cf0 \cb1 \
\
\cb3 drive_base.move_tank\cf5 (\cf8 -100\cf0 ,\cf6 'cm'\cf0 ,\cf8 90\cf0 ,\cf8 100\cf5 )\cf0 \cb1 \
\
\cf2 \cb3 raise\cf0  SystemExit\cb1 \
\
\
\
}